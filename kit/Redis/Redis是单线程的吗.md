https://xie.infoq.cn/article/d01329aceeed184a8e71575ff

#### Redis到底是单线程还是多线程?

---

我们常说的Redis是单线程的, 主要是指Redis在网络IO和键值对读取是采用一个线程来完成的, 这也是Redis对外提供键值存储服务的核心流程. 但对于Redis的其它功能来说, 比如持久化、异步删除、集群数据同步等, 其实都是由额外的线程执行的.

#### 为什么要融入多线程?

---

##### 单线程的优势:

1. 使用单线程可以避免频繁的上下文切换
2. Redis中有各种类型的数据操作, 甚至包括一些事务处理, 如果采取多线程, 还可能因为加锁导致软件复杂度提升, 更有可能会因为加解锁, 甚至出现死锁, 造成性能损耗, 所以使用单线程性能反而会更好.

##### 单线程的劣势:

1. 无法发挥多核CPU的优势
2. 当删除大键等耗时命令时, 会导致服务阻塞.
3. QPS达到瓶颈

#### Redis单线程模型

---

Redis基于Reactor模式开发了网络事件处理器, 这个处理器被称为文件事件处理器.

##### 文件事件处理器的四个重要组成部分:

1. 多个套接字请求
2. IO多路复用器
3. 文件事件派发器
4. 事件处理器

Redis客户端对服务器的每次调用都经历了发送命令、执行命令、和返回结果三个过程.

其中执行命令阶段, 由于Redis是单线程来处理命令的, 所以每一条到达服务器的命令不会被立刻执行, 所有的命令都会进入一个队列中, 然后逐个执行. 并且多个客户端发送的命令的执行顺序是不确定的.

但是可以确定的是不会有两条命令被同时执行, 不会产生并发问题.

#### 理解Redis处理流程

---

##### Redis 4.0 之前的事件处理流程

Redis通过IO多路复用器监听来自客户端的socket网络连接, 然后由主线程进行IO请求的处理和命令的处理, 多有的操作都是线性的.

##### Redis 4.0 之后加入Lazy Free机制

Redis 4.0 之前在处理客户端命令和 IO 操作时都是以单线程形式运行，期间不会响应其他客户端请求，但若客户端向 Redis 发送一条耗时较长的命令，比如删除一个含有上百万对象的 Set 键，或者执行 flushdb，flushall 操作，Redis 服务器需要回收大量的内存空间，这事就会导致 Redis 服务阻塞，对于负载较高的缓存系统来说将会是个灾难。为了解决这个问题，在 Redis 4.0 版本引入了 Lazy Free，目的是将慢操作异步化，这也是在事件处理上向多线程迈进了一步.

##### Redis 6.0 之后将网络IO异步化

从以上的发展历程中，我们也能看出 Redis 的瓶颈并不在 CPU 上，即使是单线程 Redis 也能做到很快的响应，除非是遇到个别极其耗时的命令，这一块我们的 Redis 也在 4.0 版本做出了优化，但是我们是不是能更进一步优化 Redis 呢？从上图中我们可以看出主线程不光处理大量的命令，还需要处理大量的网络 IO，Redis6.0 就是基于此，将 IO 操作交由其他线程处理

#### Lazy Free

---

惰性删除或延迟释放(Lazy Free), 指在删除key时, 采用异步方式延迟释放key所使用的内存, 该操作交给单独的字线程BIO(Background I/O)进行处理, 避免在用不删除KEY对Redis主线程的长期占用而影响系统的可用性.

在删除超大key如单个key占用内存过多或单个key包含过多元素时, 同步删除会导致redis段时间不可用, 甚至会导致主动故障切换.

在Redis 4.0版本开始提供惰性删除特性.

##### Lazy Free使用场景

1. 主动使用惰性删除特性
2. 被动使用惰性删除特性

##### 主动惰性删除

`UNLINK`命令

使用UNLINK删除集合键时, 会按照集合键的元素去估算释放该key的成本

如果释放成本超过LAZYFREE_THRESHOLD, 则会采用Lazy Free方式进行处理

`FLUSHALL/FLUSHDB`命令

通过ASYNC选项来设置FLUSHALL或者FLUSHDB操作是否采用Lazy Free方式处理.

##### 被动使用惰性删除

```
# 在内存到达最大限制需要逐出数据时使用
# 建议关闭, 避免内存未及时释放
lazyfree-lazy-eviction no
# 在key过期时使用
# 建议开启
lazyfree-lazy-expire no
# 隐式删除数据时, 如rename操作
# 建议开启
lazyfree-lazy-server-del no
# 在对从句进行全量数据同步时
# 建议关闭
slave-lazy-flush no
```



























































