#### 1. 索引

---

##### 1.1 什么是索引

在关系型数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。

索引提供指向存储在表的指定列中的数据值的指针，然后根据您指定的排序顺序对这些指针排序。数据库使用索引以找到特定值，然后顺指针找到包含该值的行。这样可以使对应于表的SQL语句执行得更快，可快速访问数据库表中的特定信息。

当表中有大量记录时，若要对表进行查询，第一种搜索信息方式是全表搜索，是将所有记录一一取出，和查询条件进行一一对比，然后返回满足条件的记录，这样做会消耗大量数据库系统时间，并造成大量磁盘I/O操作；第二种就是在表中建立索引，然后在索引中找到符合查询条件的索引值，最后通过保存在索引中的ROWID（相当于页码）快速找到表中对应的记录。

##### 1.2 聚集索引

InnoDB存储引擎是索引组织表, 表数据按照主键顺序存放, 而聚集索引就是按照每张表的主键构造的一棵B+树, 同时叶子结点存放整张表的行记录数据, 也将聚集索引的叶子节点成为数据页. 每张表只能拥有一个聚集索引. 查询优化器倾向使用聚集索引.

##### 1.3 非聚集索引

叶子节点不包含记录的全部数据. 叶子节点中索引行还包含了一个书签, 用来告诉InnoDB存储引擎在哪里可以找到与索引相对应的行数据, 这个书签就是相应行数据的聚集索引键. 可以有多个非聚集索引. 使用非聚集索引来寻找数据时, 通过叶子节点的指针获取到指向主键索引的主键, 再通过主键索引找到一个完整的行记录.

##### 1.4 回表查询

当我们进行查询的时候使用的是主键索引, 一次就可以查询出我们所需要的数据.

当我们进行查询的时候使用的是非聚集索引, 需要先通过非聚集索引找到对应的主键, 然后再通过主键查询到所需要的记录, 这个过程叫做回表查询.

##### 1.4 什么是联合索引/符合索引

联合索引就是**数据表中的多个字段，共同组成一个索引**。 由于InnoDB 中索引的数据结构是一个B+Tree，当是一个联合索引的时候，排序的时候会首先按照联合索引的第一个字段排序，如果第一个字段的值相同，则按照第二个字段排序，如果第二个字段的值也相同，则按照第三个字段排序，以此类推。

##### 1.5 索引覆盖

在使用索引查询时, 使它的索引树的叶子节点上的数据可以覆盖你查询的所有字段, 这样就可以避免回表了.

##### 1.6 最左匹配原则

指的是在联合索引中, 优先走最左边列的索引. 对于多个字段的联合索引, 也同理. 如index(a,b,c)联合索引, 则相当于创建了a单列索引, (a, b)联合索引, (a,b,c)联合索引.

当条件是a, c是也走索引, 只不过只匹配a的索引.

##### 1.7 为什么使用联合索引

1. 减少开销. 见一个联合索引(col1, col2, col3), 实际相当于创建了(col1), (col1, col2), (col1, col2, col3)三个索引. 每多一个索引, 都会增加写操作的开销和磁盘空间的开销. 对于大数据量的表, 使用联合索引大大的减少开销.

2. 索引覆盖. 对于联合索引(col1, col2, col3), 如果有如下的sql: select col1, col2, col3 from test where col1 = 1 and col2 = 2. 那么数据库可以直接通过遍历索引取得数据, 而无需回表, 这样减少很多的随机io操作. 减少io操作, 特别的随机io其实是dba主要的优化策略.
3. 效率高. 索引列越多, 通过索引筛选出的数据越少.

##### 1.8 唯一索引

Mysql在创建唯一索引时, 会在索引的B+树结构中建立一个哈希表, 用于存储索引的键值. 当向表中插入一行数据时, Mysql会先在哈希表中查询是否存在相同的键值, 如果不存在则插入数据, 否则返回错误. 因此, 唯一索引可以快速验证数据的唯一性, 并且能够提高查询和排序的效率.



#### 2. 索引的作用

---

索引的作用相当于图书的目录, 可以根据目录中的页码快速找到所需的内容. 索引提供指向存储在表的指定列中的数据值的指针, 然后根据您指定的排序顺序对这些指针排序. 数据库使用索引以找到特定值, 然后顺时针找到包含该值的行. 这样可以使对应表的sql语句执行得更快, 可快速访问数据库中的特定的信息.



#### 3. 索引的实现方式

---

1. B+Tree
2. B-Tree



### 4. 索引的使用场景

---

#### 4.1 什么场景适合使用索引

##### 4.1.1 字段的值有唯一性限制

业务上具有唯一特性的字段, 即使是组合字段, 也必须建成唯一索引.

如: 学生表里的学号

##### 4.1.2 频繁作为where查询条件的字段

如: 用户权益数据中的手机号, 经常使用手机号CRUD

##### 4.1.3 经常group by和order by的列

索引就是让数据按照某种顺序进行存储或检索, 因此当我们使用group by对数据进行分组查询或者使用order by对数据进行排序的时候, 就需要对分组或者排序的字段进行索引.

##### 4.1.4 DISTINCT字段需要创建索引

我们需要对某个字段进行去重, 使用DISTINCT, 那么我们可以对这个字段创建索引, 也会提升查询效率.

##### 4.1.5 多表JOIN连接操作时

a. 连接表的数量尽量不要超过3张, 因为每增加一张关联表相当于增加了一次嵌套的循环, 数量级增长会非常快, 严重影响查询的效率.

b. 对`where`条件创建索引, 因为`where`条件才是对数据进行过滤, 如果在数据量非常大的情况下, 没有`where`条件过滤是非常可怕的.

c. 对用于连接的字段创建索引, 并且该字段在多张表的类型必须保持一致.

##### 4.1.6 使用列的类型小的创建索引

​	a. 数据类型越小, 在查询时进行的比较操作越快

​	b. 数据类型越小, 索引占用的存储空间就越小, 在一个数据页就可以放下更多的记录, 从而减少磁盘IO带来的性	能损耗, 也就意味着可以把更多的数据页缓存在内存中, 从而加快读写效率.

这个对于主键更加适用, 聚集索引和非聚集索引都会存主键值, 如果主键值使用更小的数据类型, 也就意味着节省更多的存储空间和更高效的IO.

##### 4.1.7 使用字符串前缀创建索引

假设我们的字符串很长, 那存储一个字符串就需占用很大的存储空间, 在我们为这个字符串创建索引时, 就会存在两个问题:

​	a. B+树索引中的记录需要把该列完整字符串存储起来, 更费时, 而且字符串越长, 在索引中占用的存储空间就越	大.

​	b. 如果B+树索引中索引存储的字符串很长, 那在做字符串比较时会占用更多的时间.

我们可以通过截取字符串的前面一部分内容建立索引, 这个就叫做前缀索引. 这样查找记录时虽然不能精确定位到记录的位置, 但是能定位到相应前缀所在的位置, 然后根据前缀相同的记录再回表查询完整的字符串数据. 既节约空间, 又减少了字符串的比较时间, 还能大体解决排序的问题.

- 问题: 前缀索引对排序的影响

比方说前边只把address 列的**前12个字符**放到了二级索引中, 因为二级索引中不包含完整的address列信息，所以无法对前12个字符相同，后边的字符不同的记录进行排序，也就是使用索引前缀的方式**无法支持使用索引排序**，只能使用文件排序

阿里巴巴规范: 在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。

##### 4.1.8 区分度高(散列性高)的列适合作为索引

列的基数指的是某一列中不重复数据的个数

在记录行数一定的情况下, 列的技术越大, 该列中的值越分散; 列的基数越小, 该列中的值越集中.

列的基数越大索引效果越好

##### 4.1.9 使用最常用的列放在联合索引的左侧

这样可以减少索引的创建, 由于"最左匹配原则", 可以增加联合索引的使用率.

##### 4.1.10 在多个字段都要创建索引的情况下, 联合索引优于单值索引

多个单列索引在多条件查询时优化器会选择最优索引策略, 可能只用一个索引, 也可能将多个索引全用上.

但多个单列索引底层会创建多个B+树索引, 比较占用空间, 也会浪费一定的搜索效率.

#### 4.2 什么场景不适合使用索引

##### 4.2.1 数据量小的表最好不要使用索引

如果表数据量非常少, 那就不需要创建索引, 是否创建索引对查询效率的影响并不大, 查询花费的时间可能比遍历索引的时间还要短, 创建索引不会有优化效果.

##### 4.2.2 区分度低(离散性低)的列不适合作为索引

我们经常对离散性较高的字段建立索引, 比如学生表的性别字段只有男和女两个不同值, 因此无需创建索引. 如果建立索引, 不但不会提高查询效率, 而且严重降低数据的更新速度.

##### 4.2.3 避免对经常更新的表创建过多的索引

频繁更新的字段不一定要创建索引, 因为更新数据同时也需要更新索引, 如果索引太多, 在更新索引的时候也会造成负担, 从而影响速率.

避免对经常更新的表创建过多的索引, 并且索引中的列尽可能少, 此时虽然提高了查询效率, 但是降低了更新表的速度.

##### 4.2.4 不建议对无序的值作为索引

例如身份证、UUID、MD5、HASH等类型的索引比较时需转换为ASCII, 并且插入时可能造成列分裂.

##### 4.2.5 不要定义冗余的索引

a. 冗余索引

index(a,b,c)相对于index(a), index(a,b)

b. 重复索引

对主键又添加了一个普通索引



### 5. 查看SQL是否走索引

---

#### 5.1 EXPLAIN语句查询执行计划

##### 5.1.1 案例

```
explain select * from <table> where <field = value>;
```

需要关注的是`type`字段, 它会告诉你查询使用了哪种类型的访问方法.

如果`type`是`index、range、ref、const`等值, 表面查询使用了索引.

`explain`结果中`type`的常见字段类型:

##### system: 系统表, 少量数据

​	在Mysql服务启动时候已经加载在内存中, 不需要进行磁盘IO

##### const: 常量连接

​	命中主键或者唯一索引

##### eq_ref: 主键或者非空唯一索引等值扫描

​	连表

##### ref: 非主键非唯一索引等值扫描

​	普通非唯一索引

##### range: 范围扫描

​	between

​	in

​	>=等 

##### index: 索引树扫描

​	index类型, 需扫描索引上的所有数据

​        select count(1) from <table>

##### ALL: 全表扫描

​	不走索引, 全表扫描







