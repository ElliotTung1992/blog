#### 1. 索引

---

##### 1.1 什么是索引

在关系型数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。

索引提供指向存储在表的指定列中的数据值的指针，然后根据您指定的排序顺序对这些指针排序。数据库使用索引以找到特定值，然后顺指针找到包含该值的行。这样可以使对应于表的SQL语句执行得更快，可快速访问数据库表中的特定信息。

当表中有大量记录时，若要对表进行查询，第一种搜索信息方式是全表搜索，是将所有记录一一取出，和查询条件进行一一对比，然后返回满足条件的记录，这样做会消耗大量数据库系统时间，并造成大量磁盘I/O操作；第二种就是在表中建立索引，然后在索引中找到符合查询条件的索引值，最后通过保存在索引中的ROWID（相当于页码）快速找到表中对应的记录。

##### 1.2 聚集索引

InnoDB存储引擎是索引组织表, 表数据按照主键顺序存放, 而聚集索引就是按照每张表的主键构造的一棵B+树, 同时叶子结点存放整张表的行记录数据, 也将聚集索引的叶子节点成为数据页. 每张表只能拥有一个聚集索引. 查询优化器倾向使用聚集索引.

##### 1.3 非聚集索引

叶子节点不包含记录的全部数据. 叶子节点中索引行还包含了一个书签, 用来告诉InnoDB存储引擎在哪里可以找到与索引相对应的行数据, 这个书签就是相应行数据的聚集索引键. 可以有多个非聚集索引. 使用非聚集索引来寻找数据时, 通过叶子节点的指针获取到指向主键索引的主键, 再通过主键索引找到一个完整的行记录.

##### 1.4 回表查询

当我们进行查询的时候使用的是主键索引, 一次就可以查询出我们所需要的数据.

当我们进行查询的时候使用的是非聚集索引, 需要先通过非聚集索引找到对应的主键, 然后再通过主键查询到所需要的记录, 这个过程叫做回表查询.

##### 1.4 什么是联合索引/符合索引

联合索引就是**数据表中的多个字段，共同组成一个索引**。 由于InnoDB 中索引的数据结构是一个B+Tree，当是一个联合索引的时候，排序的时候会首先按照联合索引的第一个字段排序，如果第一个字段的值相同，则按照第二个字段排序，如果第二个字段的值也相同，则按照第三个字段排序，以此类推。

##### 1.5 索引覆盖

在使用索引查询时, 使它的索引树的叶子节点上的数据可以覆盖你查询的所有字段, 这样就可以避免回表了.

##### 1.6 最左匹配原则

指的是在联合索引中, 优先走最左边列的索引. 对于多个字段的联合索引, 也同理. 如index(a,b,c)联合索引, 则相当于创建了a单列索引, (a, b)联合索引, (a,b,c)联合索引.

当条件是a, c是也走索引, 只不过只匹配a的索引.

##### 1.7 为什么使用联合索引

1. 减少开销. 见一个联合索引(col1, col2, col3), 实际相当于创建了(col1), (col1, col2), (col1, col2, col3)三个索引. 每多一个索引, 都会增加写操作的开销和磁盘空间的开销. 对于大数据量的表, 使用联合索引大大的减少开销.

2. 索引覆盖. 对于联合索引(col1, col2, col3), 如果有如下的sql: select col1, col2, col3 from test where col1 = 1 and col2 = 2. 那么数据库可以直接通过遍历索引取得数据, 而无需回表, 这样减少很多的随机io操作. 减少io操作, 特别的随机io其实是dba主要的优化策略.
3. 效率高. 索引列越多, 通过索引筛选出的数据越少.

##### 1.8 唯一索引

Mysql在创建唯一索引时, 会在索引的B+树结构中建立一个哈希表, 用于存储索引的键值. 当向表中插入一行数据时, Mysql会先在哈希表中查询是否存在相同的键值, 如果不存在则插入数据, 否则返回错误. 因此, 唯一索引可以快速验证数据的唯一性, 并且能够提高查询和排序的效率.

#### 2. 索引的作用

---

索引的作用相当于图书的目录, 可以根据目录中的页码快速找到所需的内容. 索引提供指向存储在表的指定列中的数据值的指针, 然后根据您指定的排序顺序对这些指针排序. 数据库使用索引以找到特定值, 然后顺时针找到包含该值的行. 这样可以使对应表的sql语句执行得更快, 可快速访问数据库中的特定的信息.

#### 3. 索引的实现方式

---

1. B+Tree
2. B-Tree

### 4. 索引的使用场景

---

#### 4.1 什么场景适合使用索引

##### 4.1.1 字段的值有唯一性限制

业务上具有唯一特性的字段, 即使是组合字段, 也必须建成唯一索引.

如: 学生表里的学号

1. 频繁作为where查询条件的字段
2. 经常group by和order by的列
3. DISTINCT字段需要创建索引
4. 多表JOIN连接操作时
5. 使用列的类型小的创建索引
6. 使用字符串前缀创建索引
7. 区分度高(散列性高)的列适合作为索引
8. 使用最常用的列放在联合索引的左侧
9. 在多个字段都要创建索引的情况下, 联合索引优于单值索引

#### 4.2 什么场景不适合使用索引

1. 数据量小的表最好不要使用索引
2. 区分度低(离散性低)的列不适合作为索引
3. 避免对经常更新的表创建过多的索引
4. 不建议对无序的值作为索引
5. 不要定义冗余的索引

### 5. 查看SQL是否走索引

---

#### 5.1 EXPLAIN语句查询执行计划

##### 5.1.1 案例

```
explain select * from <table> where <field = value>;
```

需要关注的是`type`字段, 它会告诉你查询使用了哪种类型的访问方法.

如果`type`是`index、range、ref、const`等值, 表面查询使用了索引.

`explain`结果中`type`的常见字段类型:

##### system: 系统表, 少量数据

​	在Mysql服务启动时候已经加载在内存中, 不需要进行磁盘IO

##### const: 常量连接

​	命中主键或者唯一索引

##### eq_ref: 主键或者非空唯一索引等值扫描

​	连表

##### ref: 非主键非唯一索引等值扫描

​	普通非唯一索引

##### range: 范围扫描

​	between

​	in

​	>=等 

##### index: 索引树扫描

​	index类型, 需扫描索引上的所有数据

​        select count(1) from <table>

##### ALL: 全表扫描

​	不走索引, 全表扫描







