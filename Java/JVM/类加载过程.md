#### 类的生命周期

---

类从被加载到虚拟机内存中到卸载出内存, 它的整个生命周期可以简单概括为7个阶段:

1. 加载(loading)
2. 验证(verification) - 链接(linking)
3. 准备(preparation) - 链接
4. 解析(resolution) - 链接
5. 初始化(initialization)
6. 使用(using)
7. 卸载(unloading)

#### 类的加载过程

---

Class文件需要加载到虚拟机中之后才能运行和使用, 那么虚拟机是如何加载这些Class文件呢？

系统加载Class类型的文件主要三步: 加载->链接->初始化. 

链接过程又可以分为三步: 验证->准备->解析.

#### 加载

---

类加载过程主要完成下面3件事情:

1. 通过全类名获取定义此类的二进制字节流
1. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
1. 在内存中生成一个代表该类的`Class`对象, 作为方法区这些数据的访问入口

加载这一步骤主要通过类加载器完成. 类加载器有很多种, 当我们想要加载一个类的时候，具体是哪个类加载器加载由 **双亲委派模型** 决定.

每个Java类都有一个引用指向加载它的`ClassLoader`. 不过, 数组类不是通过`ClassLoader`创建的, 而是JVM在需要的时候自动创建的, 数组类通过`getClassLoader()`方法获取`ClassLoader`的时候和该数组的元素类型的`ClassLoader`是一致的.

加载阶段和链接阶段的部分动作是交叉进行的, 加载阶段尚未结束, 链接阶段可能就已经开始了.

##### 验证

验证是链接阶段的第一步, 这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求, 保证这些信息被当作代码运行后不会危害虚拟机自身的安全.

验证阶段这一步在整个类加载过程中消耗的资源还是相对较多的, 但是有必要, 可以有效防止恶意代码的执行. 任何时候, 程序安全都是第一位.

不过, 验证阶段也不是必须要执行的阶段. 如果程序运行的全部代码(包括自己编写的包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复使用和验证过, 在生产环境的实施阶段就可以考虑使用`-Xverify:none`参数来关闭大部分的类验证措施, 以缩短虚拟机类加载的时间.

验证阶段主要由四个校验阶段组成:

1. 文件格式验证(Class文件格式检查)
2. 元数据验证(字节码语义检查)
3. 字节码验证(程序语义检查)
4. 符号引用验证(类的正确性检查)

##### 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段, 这些内存将在方法区中分配.

该阶段需要注意以下这几个点:

1. 这时候进行内存分配的仅包括类变量, 而不包括实例变量. 实例变量会在对象实例化时随着对象一起分配在Java堆中.
2. 从概念上讲，类变量所使用的内存都应当在 **方法区** 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中.
3. 这里所设置的初始值"通常情况"下是数据类型默认的零值（如 0、0L、null、false 等），比如我们定义了`public static int value=111` ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字`public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111.

##### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程. 

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行.

举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。

综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。

##### 初始化

初始化阶段是执行初始化方法`<clinit>()`方法的过程, 是类加载的最后一步, 这一步JVM才开始真正执行类中定义的Java程序代码(字节码).

`<clinit> ()`方法是编译之后自动生成的

对于`<clinit> ()` 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 `<clinit> ()` 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞，并且这种阻塞很难被发现

对于初始化阶段，虚拟机严格规范了有且只有 6 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：

1. 当遇到 `new`、 `getstatic`、`putstatic` 或 `invokestatic` 这 4 条字节码指令时，比如 `new` 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时.
   - 当 jvm 执行 `new` 指令时会初始化类. 即当程序创建一个类的实例对象.
   - 当 jvm 执行 `getstatic` 指令时会初始化类.即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池).
   - 当 jvm 执行 `putstatic` 指令时会初始化类. 即程序给类的静态变量赋值
   - 当 jvm 执行 `invokestatic` 指令时会初始化类. 即程序调用类的静态方法
2. 使用 `java.lang.reflect` 包的方法对类进行反射调用时如 `Class.forName("...")`, `newInstance()` 等等。如果类没初始化，需要触发其初始化。
3. 初始化一个类, 如果其父类还未初始化, 则先触发该父类的初始化.
4. 当虚拟机启动时, 用户需要定义一个要执行的主类 (包含 `main` 方法的那个类)，虚拟机会先初始化这个类.
5. `MethodHandle` 和 `VarHandle` 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，
   就必须先使用 `findStaticVarHandle` 来初始化要调用的类
6. 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化.

##### 类卸载

类卸载即该类的Class对象被GC.

类卸载需要满足3个条件:

1. 该类的所有的实例对象都已被GC, 也就是说堆不存在该类的实例对象.
2. 该类没有在其他任何地方被引用.
3. 该类的类加载器的实例已被GC.

所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

只要想通一点就好了，JDK 自带的 `BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的.

























