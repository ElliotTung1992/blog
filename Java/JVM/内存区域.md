#### 运行时数据区

---

##### 线程私有的:

1. 程序计数器
2. 虚拟机栈
3. 本地方法栈

##### 线程共享的:

1. 堆
2. 方法区
3. 直接内存

#### 程序计数器

---

程序计数器是一块较小的内存空间, 可以看作是当前线程所执行的字节码的行号指示器.

字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令、分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成.

另外, 为了线程切换后能恢复到正确的执行位置, 每个线程都需要一个独立的程序计数器, 各个线程之间计数器互不影响, 独立存储, 我们称为这种内存区域为线程私有的内存.

程序计数器主要有两个作用:

1. 字节码解释器通过改变程序计数器来依次读取指令, 从而实现代码的流程控制, 如: 顺序执行、选择、循环、异常处理.
2. 在多线程的情况下, 程序计数器用来记录当前线程执行的位置, 从而当线程被切换回来的时候就能够知道线程上次运行到哪里了.

注意:

程序计数器是唯一一个不会出现`OutOfMemoryError`的内存区域, 它的生命周期随着线程的创建而创建, 随着线程的结束而死亡.

#### Java虚拟机栈

---

与程序计数器一样, Java虚拟机栈也是线程私有的, 它的生命周期和线程相同, 随着线程的创建而创建, 随着线程的死亡而死亡.

栈是JVM运行时数据区的核心, 除了一些Native方法调用是通过本地方法栈实现的, 其他所有的Java方法调用都是通过栈来实现的.

方法调用的数据需要通过栈进行传递, 每一次方法调用都会有一个对应的栈帧被压入栈中, 每一个方法调用结束后, 都会有一个栈帧被弹出.

栈由一个个栈帧组成, 而每一个栈帧中都拥有: `局部变量表、操作数栈、动态链接、方法返回地址`. 和数据结构上的栈类似, 两者都是先进后出的数据结构, 只支持出栈和入栈两种操作.

##### 局部变量表

主要存放了编译期可知的各种数据类型(boolean, byte, char, short, int, float, long, double), 对象引用(reference类型, 它不同于对象本身, 可能是一个指向对象起始地址的引用指针, 也可能是指向一个代表对象的句柄或其他与此对象相关的位置).

##### 操作数栈

主要作为方法调用的中转站使用, 用于存放方法执行过程中产生的中间计算结果. 另外, 计算过程产生的临时变量也会放在操作数栈中.

##### 动态链接

主要服务一个方法需要调用其他方法的场景. Class文件的常量池里保存有大量的符号引用比如方法引用的符号引用. 当一个方法要调用其他方法, 需要将常量池中指向方法的符号引用转换为其在内存地址中的直接引用. 动态链接的作用是为了将符号引用转换为调用方法的直接引用, 这个过程被称为动态链接.

##### 方法的返回方式

1. return语句正常返回
2. 抛出异常

以上两种方式都会导致栈帧被弹出. 也就是说, 栈帧随着方法调用而创建, 随着方法结束而销毁. 无论方法正常返回还是抛出异常都算作为方法结束.

##### 栈可能出现的异常

栈空间虽然不是无限的, 但是一般情况下是不会出现异常的. 不过, 如果函数调用陷入无限循环, 就会导致栈中被压入太多栈帧而占用过多空间, 导致栈空间过深. 那么当线程请求栈的深度超过当前虚拟机栈的最大深度的时候, 就抛出`StackOverFlowError`错误.

栈还可能会出现`OutofMemoryError`错误, 这是因为如果栈的内存大小可以动态扩展, 如果虚拟机在动态扩展栈时无法申请到足够的内存空间, 则会排出`OutOfMemoryError`异常.

简单总结一下程序运行中栈可能会出现的两种错误:

1. `StackOverFlowError`: 那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度时, 就抛出`StackOverFlowError`
2. `OutOfMemoryError`: 如果栈的内存大小可以动态扩展, 如果虚拟机在动态扩展栈的时候无法申请到足够的内存空间, 则抛出`OutOfMemoryError`

#### 本地方法栈

---

和虚拟机栈所发挥的作用非常相似, 区别是: 虚拟机栈为虚拟机执行Java方法(也就是字节码)服务, 而本地方法栈则为虚拟机使用到的Native方法服务. 在HotSpot虚拟机中和Java虚拟机栈合二为一.

本地方法被执行的时候, 在本地方法栈也会创建一个栈帧, 用于存放该本地方法的局部变量表、操作数栈、动态链接、方法返回地址.

本地方法执行完毕后相应的栈帧也会出栈并释放内存空间, 也会出现`StackOverFlowError`和`OutOfMemoryError`两种错误

#### 虚拟机堆

---

**JVM内存**会划分为**堆内存**和**非堆内存**

**堆内存**可以划分为**年轻代**和**老年代**

**而非堆内存**则为**永久代**.

**年轻代**可分为**Eden**和**Survivor**区.

**Survivor区**可分为**FromPlace**和**ToPlace**, **ToPlace**的**Survivor区**是空的.

**Eden**、**FromPlace**和**ToPlace**的默认占比是8:1:1.

当然这个东西其实也可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整

堆内存中存放的是对象, 垃圾收集就是收集这些对象然后交给GC算法进行回收. 

而非堆内存其实我们已经说过了就是方法区. 在1.8中已经移除永久代, 替代品是一个元空间(MetaSpace), 最大的区别是MetaSpace是不存在于JVM中, 它使用的是本地内存.

有两个参数控制：

```
MetaspaceSize：初始化元空间大小，控制发生GC
MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。
```

移除的原因可以大致了解下: 融合HotSpot JVM和JRockit VN而做出的改变, 因为JRockit是没有永久代的, 不过这也间接地解决了永久代的OOM问题.

##### Eden年轻代

当我们new一个对象后, 会先放到Eden年轻代划分出来的一块作为存储空间的内存, 但是我们知道堆内存是线程共享的, 所以有可能出现两个对象共用一个内存的情况. 这里JVM的处理是为那个线程都预先申请好一块连续的内存空间并规定了对象存放的位置, 而如果空间不足会再申请多块内存空间. 这个操作我们会称为TLAB.

当Eden空间满了以后, 会触发一个叫做Minor GC(就是一个发生在年轻代的GC)的操作, 存活下来的对象移动到Survivor区, 此时还会把from和to两个指针互换, 这样保证了一段时间内总有一个Survivor区为空且to所指向的Survivor区为空. 经过多次的Minor GC后任然存活的对象(这里的存活判断是15次, 对应到虚拟机参数为XX: MaxTenuringThreshold)为什么是15？, 因为HotSpot会在对象头中的标记字段里记录年龄, 分配到的空间只有4位, 所以最多只能记录到15.记录位15的对象会移动到老年代.

##### Survivor0区的对象什么时候进行垃圾回收?

假设Survivor0区现在是满的, 此时又触发了Minor GC, 发现Survivor0区依旧是满的, 存不下, 此时会将S0区与Eden区的对象一起进行可达性分析, 找出活跃的对象, 将它复制到S1区并且将S0区域和Eden区的对象都清理掉, 这样讲那些不可达的对象进行清除, 并且将S0区和S1区交换.

##### 老年代

老年代是存储长期存活对象的, 占满的时候就会触发我们最常听说的Full GC, 期间会停止所有线程等待GC完成. 所以对于响应要求高的应用尽量去减少发生Full GC从而避免响应超时的问题.

而且当老年代执行了Full GC之后仍然无法进行对象保存的操作, 就会产生OOM, 着时候就是虚拟机中堆内存不足, 原因可能会是堆内存设备的大小过小, 这个可以通过参数-Xms、-Xmx来调整. 也可能是代码中创建的对象大且多, 而且它们一直在被引用从而长时间垃圾回收器无法收集它们.

补充说明:

关于-XX: TargetSurvivorRatio参数的问题. 其实也不一定是要满足-XX:MaxTenuringThreshold才移动到老年代.

可以举个例子: 如对象年龄5的占30%, 年龄6的占36%, 年龄7的占34%, 加入某个年龄段(如例子中的6)后, 总占用超过Survivor空间 * TargetSurvivorRatio的时候, 从该年龄段开始及大于的年龄就要进入老年代(即例子中的年龄 6 对象，就是年龄 6 和年龄 7 晋升到老年代), 这时候就无需等到MaxTenuringThreshold 中要求的 15.

##### 如何判断一个对象需要被回收

程序计数器、虚拟机栈、本地方法栈这3个区域随着线程的生存而生存. 内存分配和回收都是确定的. 随着线程的结束内存自然就被回收了, 因此不需要考虑垃圾回收的问题. 而Java堆和方法区则不一样, 各线程共享, 内存的分配和回收都是动态的. 因此垃圾回收器所关注的都是堆和方法区这部分的内存.

在进行回收之前就需要判断哪些对象还存活, 哪些已经死去.主要用两个基础的计算方法:

1. 引用计数器计算: 给对象添加一个引用计数器, 每次引用这个对象时计数器加一, 引用失效时减一, 计数器等于0时就不会再次使用. 不过这个方法有一种情况就是出现对象循环引用时GC没法回收.
2. 可达性分析计算: 这是一种类似于二叉树的实现, 将一系列的GC ROOTS作为起始的存活对象集, 从这个节点往下搜索, 搜索所走过的路径称为引用链, 把能被该集合引用到的对象加入到集合中. 搜索当一个对象到GC Roots没任何引用链时, 则说明该对象时不可用的. 主流的商用程序语言, 例如Java, C#等都是靠这招去判断对象是否存活.

在Java语言汇总能作为GC Roots的对象分为以下几种:

1. 虚拟机栈(栈帧中的本地方法表)中引用的对象(局部变量)
2. 方法区中静态变量所引用的对象(静态变量)
3. 方法区中常量引用的对象
4. 本地方法栈(即Native修饰的方法)中JNI引用的对象
5. 已启动的且未终止的Java线程

这个方法的优点是能够解决循环引用的问题, 可它的实现需要消耗大量资源和时间, 也需要GC(它的分析过程引用关系不能发生改变, 所以需要停止所有进程)

##### 如何宣告一个对象的真正死亡

首先必须要提到的是一个名为finalize()的方法.

finalize()是Object类的一个方法, 一个对象的finalize()方法只会被系统自动调用一次, 经过finalize()方法逃脱死亡的对象, 第二次不会再调用.

判断一个对象死亡之少需要两次标记:

1. 如果对象进行可达性分析之后没发现与GC ROOTS相连的引用链, 那它将会第一次标记并且进行一次筛选. 判断的条件是决定这个对象是否有必要执行finalize方法. 如果对象有必要执行finalize()方法, 则被放入F-Queue队列中.
2. GC对F-Queue队列中的对象进行二次标记. 如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联, 那么二次标记时则会将它移出"即将回收"集合. 如果此时对象还没成功逃脱, 那么只能被回收了.

#### 方法区

---

方法区属于是JVM运行时数据区域的一块逻辑区域, 是各个线程共享的内存区域.

《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用, 方法区到底要如何实现那就是虚拟机自己要考虑的事情了. 也就是, 在不同的虚拟机实现上, 方法区的实现是不同的.

当虚拟机要使用一个类时, 它需要读取并解析Class文件获取相关信息, 再将信息存入到方法区. 方法区会存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态常量、即时编译器编译后的代码缓存等数据.

##### 方法区和永久代以及元空间是什么关系呢？

方法区和永久代以及元空间的关系很像Java中接口和类的实现的关系, 类实现了接口, 这里的类就可以看作是永久代和方法区, 也就是说永久代以及元空间时HotSpot虚拟机对虚拟机规范中方法区的两种实现方式. 并且, 永久代是JDK 1.8之前方法区的实现, JDK1.8之后方法区的实现变成了元空间.

##### 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?

在JDK6的时候HotSpot开发团队就开始放弃永久代, 逐步改成采用本地内存(Native Memory)来实现方法区的计划了, 到了JDK7的HotSpot, 已经把原本放在永久代的字符串常量池、静态变量等移出, 而到了JDK8, 终于完全废弃了永久代的概念, 终于完全废弃了永久代的概念, 改用与JRockit、J9一样在本地内存中实现的元空间(Meta-space)来代替, 把JDK7中永久代还剩余的内容(主要是类型信息)完全移到元空间中.

1. 整个永久代有一个JVM本身设置的固定大小上限, 无法进行调整(也就是受到JVM内存的限制), 而元空间使用的是本地内存, 受本机可用内存的限制, 虽然元空间仍旧可能溢出, 但是比原来出现的几率会更小.

你可以使用`-XX:MaxMetaspaceSize`标志设置最大元空间大小, 默认值为unlimited, 这意味着它只受系统内存的限制. `-XX:MetaspaceSize`调整标志定义元空间的初始大小如果未指定此标志, 则Metaspace将根据运行时的应用程序需求动态地重新调整大小.

2. 元空间里面存放的是类的元数据, 这样加载多少类的元数据就不由`MaxPermSize`控制了, 而由系统的实际可用空间来控制, 这样能加载的类更多了.
3. 在JDK8, 合并HotSpot和JRockit的代码时, JRockit从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置一个永久代的地方了.
4. 永久代为GC带来了不必要的复杂度, 并且回收效率低.

##### 方法区常用参数有哪些?

JDK1.8之前永久代还没被彻底移除的时候通常通过下面这些参数来调整方法区大小

```
-XX:PermSizw=N // 方法区(永久代)初始大小
-XX:MaxPermSize=N // 方法区(永久代)最大大小, 超过这个值将会抛出OutOfMemoryError
```

相对而言, 垃圾收集行为在这个区域是比较少出现的, 但并非数据进入方法区就永远存在了.

JDK1.8的时候, 方法区(HotSpot的永久代)被彻底移除了(JDK1.7就已经开始了), 取而代之的是元空间, 元空间使用的是本地内存. 下面是一些常用的参数：

```
-XX:MetaspaceSize=N //设置Metaspace的初始大小
-XX:MaxMetaspaceSize=N //设置Metaspace的最大大小
```

与永久代很大不同的是, 如果不指定大小的话, 随着更多类的创建, 虚拟机会耗尽所有可用的系统内存.

#### 运行时常量池

---

Class文件中除了有类的版本、字段、方法、接口等描述信息外, 还有用于存放编译期生成的各种字面量(Literal)和符号引用(Symbolic Reference)的常量池表(Constant Pool Table).

字面量是源代码中固定值的表示法, 即通过字面我们就能知道其值的含义. 字面量包括整数、浮点数和字符串字面量. 常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号.

**符号引用(Symbolic Reference):** 符号引用以一组符号来描述所引用的目标, 符号可以时任何形式的字面量, 只要使用时能无歧义地定位到目标即可. 符号引用与虚拟机实现的内存布局无关, 引用的目标并不一定是已经加载到虚拟机内容当中的内容. 各种虚拟机实现的内存布局可以各不相同, 但是它们能接受的符号引用必须是一致的, 因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中.

**直接引用(Direct Reference):** 直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位目标的句柄.直接引用是和虚拟机实现的内存布局直接相关的, 同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同. 如果有了直接引用, 那引用的目标必定已经在虚拟机的内存中存在.

常量池表会在类加载后存放到方法区的运行时常量池中.

运行时常量池的功能类似于传统编程语言的符号表, 尽管它包含了比较典型符号表更广泛的数据.

既然运行时常量池是方法区的一部分, 自然受到方法区内存的限制, 当常量次无法再申请到内存时会抛出`OutOfMemoryError`错误.

#### 字符串常量池

---

字符串常量池是JVM为了提升性能或减少内存消耗针对字符串(String类)专门开辟的一块区域, 主要是为了避免字符串的重复创建.

```
String aa = "ab";
String bb = "ab";
sout(aa == bb); // true
```

HopSpot虚拟机中字符串常量池的实现是src/hotspot/share/classfile/stringTable.cpp,StringTable可以简单理解为一个固定大小的`HashTable`, 容量为`StringTableSize`(可以通过`-XX:StringTableSize`参数来设置), 保存的是字符串(key)和字符串对象的引用(value)的映射关系, 字符串对象的引用指向的字符串对象.

JDK1.7之前, 字符串常量池存放在永久代. JDK1.7字符串常量池和静态变量从永久代移到了Java堆中.

##### JDK1.7为什么要将字符串常量池移动到堆中?

主要是因为永久代(方法区实现)的GC回收效率太低, 只有在整堆收集(Full GC)的时候才会被执行GC. Java程序中通常会有大量的被创建的字符串等待回收, 将字符串常量池放到堆中, 能够更高效及时回收字符串内存.

##### JVM常量池中存储的是对象还是引用呢?

// todo

运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念, 是公共且抽象的, Metaspace、Heap是与具体某种虚拟机实现相关的物理概念, 是私有且具体的.

#### 直接内存

---

直接内存是一种特殊的内存缓冲区, 并不在Java堆或方法区中分配的, 而是通过JNI的方式在本地内存上分配的.

直接内存并不是虚拟机运行时数据区的一部分, 也不是虚拟机规范中定义的内存区域, 但是这部分内存也会被频繁地使用. 而且也可能导致`OutOfMemoryError`错误出现.

JDK1.4 中新加入的 **NIO（Non-Blocking I/O，也被称为 New I/O）**，引入了一种基于**通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据**.

直接内存的分配不会受到Java堆的限制, 但是, 既然是内存就会受到本机总内存大小以及处理器寻址空间的限制.

类似的概念还有堆外内存. 在一些文章中将直接内存等价于堆外内存, 个人觉得不是特别准确.

堆外内存就是把内存对象分配在堆外的内存, 这些内存直接受操作系统管理(而不是虚拟机), 这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成影响.







































