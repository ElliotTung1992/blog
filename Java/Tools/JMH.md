#### 引言

JMH全称(Java Microbenchmark Harness)是用于代码微基准测试的工具套件, 主要是基于方法层面的基准测试, 精度可以达到纳秒级. 

JMH比较典型的应用场景:

1. 想准确地知道某个方法需要执行多长时间, 以及执行时间和输入之间的相关性.
2. 对比接口不同实现在给定条件下的吞吐量.
3. 查看多少百分比的请求在多少时间内完成.



**JMH基础:**

**@BenchmarkMode**

用来配置 Mode 选项，可用于类或者方法上，这个注解的 value 是一个数组，可以把几种 Mode 集合在一起执行，如：`@BenchmarkMode({Mode.SampleTime, Mode.AverageTime})`，还可以设置为 `Mode.All`，即全部执行一遍。

1. Throughput：整体吞吐量，每秒执行了多少次调用，单位为 `ops/time`
2. AverageTime：用的平均时间，每次操作的平均时间，单位为 `time/op`
3. SampleTime：随机取样，最后输出取样结果的分布
4. SingleShotTime：只运行一次，往往同时把 Warmup 次数设为 0，用于测试冷启动时的性能
5. All：上面的所有模式都执行一次

**@State**

通过 State 可以指定一个对象的作用范围，JMH 根据 scope 来进行实例化和共享操作。@State 可以被继承使用，如果父类定义了该注解，子类则无需定义。由于 JMH 允许多线程同时执行测试，不同的选项含义如下：

1. Scope.Benchmark：所有测试线程共享一个实例，测试有状态实例在多线程共享下的性能
2. Scope.Group：同一个线程在同一个 group 里共享实例
3. Scope.Thread：默认的 State，每个测试线程分配一个实例

**@OutputTimeUnit**

为统计结果的时间单位，可用于类或者方法注解

**@Warmup**

预热所需要配置的一些基本测试参数，可用于类或者方法上。一般前几次进行程序测试的时候都会比较慢，所以要让程序进行几轮预热，保证测试的准确性。参数如下所示：

1. iterations：预热的次数
2. time：每次预热的时间
3. timeUnit：时间的单位，默认秒
4. batchSize：批处理大小，每次操作调用几次方法

> **为什么需要预热？**
>
> 因为 JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM 会尝试将其编译为机器码，从而提高执行速度，所以为了让 benchmark 的结果更加接近真实情况就需要进行预热。

**@Measurement**

实际调用方法所需要配置的一些基本测试参数，可用于类或者方法上，参数和 `@Warmup` 相同。

**@Threads**

每个进程中的测试线程，可用于类或者方法上。

**@Fork**

进行 fork 的次数，可用于类或者方法上。如果 fork 数是 2 的话，则 JMH 会 fork 出两个进程来进行测试。

**@Param**

指定某项参数的多种情况，特别适合用来测试一个函数在不同的参数输入的情况下的性能，只能作用在字段上，使用该注解必须定义 @State 注解。







