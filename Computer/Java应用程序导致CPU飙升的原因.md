#### Java应用程序导致CPU飙升的原因

---

问题:

1. while的无限循环是否会导致CPU飙升？
2. 频繁的Young GC是否会导致CPU飙升?
3. 有大量线程的应用程序的CPU使用率高吗?



#### while的无限循环是否会导致CPU飙升？

---

回答: 会的

分析: 无限循环会调用CPU寄存器进行计数, 这个操作会占用CPU资源.

那么, 如果线程一直处于死循环状态, CPU会不会切换线程？

除非操作系统时间片到期, 否则无限循环不会放弃占用的CPU资源, 并且无限循环会

继续向系统请求时间片, 直到系统没有空闲时间做其他的事.



#### 频繁的Young GC是否会导致CPU飙升?

---

回答: 会的

分析: Young GC本身就是JVM进行垃圾回收的操作, 需要计算内存和调用寄存器. 因此频繁的Young GC肯定会占用CPU资源.



#### 有大量线程的应用程序的CPU使用率高吗?

---

回答: 不一定

分析: 



#### 常见的CPU密集型操作有哪些?

---

人们常说, 计算密集型程序是CPU密集型程序, 那么在Java应用程序中哪些操作属于计算密集型呢？

1. 频繁的GC
2. 序列化和反序列化
3. 加密和解密
4. 正则表达式
5. 频繁线程上下文切换. 当锁竞争激烈时, 这种情况容易发生
6. 线程不断执行非阻塞操作: 如 while(true)



#### CPU和进程和线程有关吗?

---

分时操作系统采用轮训的方式为线程调度分配时间片.

如果线程正在处于等待和阻塞中, 则不会占用CPU资源, 该线程被称为轻线程.

在Java中, 我们使用JVM进行线程调度, 一般来说线程的调用有两种模式: 分时调度和抢占式调度.

进程和线程在阻塞或者等待时, 不会占用CPU资源.



#### CPU的us和sy值在分时操作系统中高是什么意思?

---

我们可以使用`top`命令查看cpu的`us`和`sy`的值:

us: 用户空间占用的CPU百分比. 如果`us`的值比较高, 则是我们程序引起的, 分析堆栈很容易定位有问题的线程.

sy: 内核空间占用的CPU百分比. 如果`sy`的值比较高, 如果是程序引起的, 基本上是线程上下文切换引起的.



























