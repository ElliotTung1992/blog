#### RocketMQ

---

##### Group

Consumer Group

Group用于标识一类Consumer, 这类Consumer通常消费同一类消息, 且消息订阅的逻辑一致.

消费模式:

- 集群模式: 当使用集群模式, 任意一条消息只需要被集群内的任意一个消费者处理即可.
- 广播模式: 当使用广播模式时, 每条消息会被推送给集群内所有注册过的消费者, 保证消息至少被每个消费者消费一次.

Producer Group

标识一类Producer的集合名称.这类Producer通常发送一类消息，且发送逻辑一致。应用自己保证ProducerGroup名字唯一，ProducerGroup这个概念发送普通的消息时，作用不大，但是发送分布式事务消息时比较关键，因为服务器会回查这个Group下的任意一个Producer

##### Tag

为消息设置的标志, 用于同一Topic下区分不同类型的消息. 

来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。

##### 订阅关系一致:

订阅关系: 一个消费者组订阅一个Topic的某一个Tag, 这种记录被称为订阅关系

订阅关系一致: 同一个消费者组下所有消费者实例所订阅的Topic、Tag必须完全一致, 如果订阅关系(消费者组名-Topic-Tag)不一致, 会导致消费消息紊乱，甚至消息丢失

#### 顺序消息

---

顺序消息分为全局顺序消息与部分顺序消息

全局顺序消息 - 指某个Topic下所有的消息都要保证顺序

部分顺序消息 - 只需要保证某个Topic下每一逻辑列消息被顺序消费即可

全局顺序消息和部分顺序消息比较:

全局顺序消息只能使用一个队列, 以及单个生产者和消费者, 严重影响性能和吞吐

##### 局部顺序消息

1. 生产者有序发送
2. 消费者有序消费

消费者有序消费有两种模式:

1. 有序消费模式 - MessageListenerOrderly
2. 并发有序消费模式 - MessageListenerConcurrently

##### 生产者有序发送

消息存储在队列中, 而队列先进先出的特性可以保证入列消息顺序和拉取的消息是一致的

我们只要保证相同逻辑的消息存储在同一队列中, 就能保证生产者有序存储

> 普通发送消息的模式:
>
> 生产者会采用轮询的方式将消息均匀的分发到不同的队列中, 然后被不同的消费者消费, 因为一组消息在不同的队列, 所以无法保证消息的顺序性.

> RocketMQ的解决方案:
>
> RocketMQ支持生产者在投递消息时候自定义投放策略, 我们实现一个MessageQueueSelector接口, 使用Hash取模法就能保证同一业务逻辑的数据在同一个队列.
>
> 以上方式可以实现统一业务逻辑的消息被顺序存放在一个队列中, 不同组的消息之间无法保证顺序, 这就是部分顺序. 

##### 延时消息

当消息写入到Broker后, 不能立刻被消费者消费, 需要等待指定的时长才能被消费处理的消息, 成为延时消息.

##### 单向消息

适用于吞吐量很大, 不关心发送结果的场景, 存在消息丢失的风险

##### 延迟消息

##### 异步消息

##### 同步消息

##### 批量消息

#### 事务消息

---

- Half Message, 半消息

暂时不能被Consumer消费的消息. Producer已经把消息发送到Broker端, 但是此消息的状态被标记为不能投递, 处于这种状态下的消息成为半消息. 事实上, 该状态下的消息会被放在一个叫做RMQ_SYS_TRANS_HALF_TOPIC的主题下.

当Producer端对它二次确认后, 也就是Commit之后, Consumer端才可以消费到; 那么如果是Rollback, 该消息则会被删除, 永远不会被消费到.

- 事务状态回查

可能因为网络原因、应用问题等, 导致Producer端一直没有对这个半消息进行确认, 那么这时候Broker服务器会定时扫描这些半消息, 主动找Producer端查询该消息的状态.

简而言之, RocketMQ事务消息的实现原理就是基于二阶段提交和状态回查, 来决定消息最终是提交还是回滚的.

##### 消费者幂等消费问题

1. messageId等唯一标识入库并添加唯一索引
2. 分布式锁 + 缓存或数据库查询校验

##### 消费者消费异常

1. 在消费者获取消息重试次数, 如果达到指定的次数则进行短信/邮件通知或数据入库处理
2. 等待消息重试最大次数后, 进入死信队列.

#### 死信队列

---

对于消费失败且重试后依然失败的消息,  云消息队列 RocketMQ 版不会立丢弃, 而是将消息转发至指定的队列中, 即死信队列，这些消息即为死信消息. 当消费失败的原因排查并解决后, 您可以重发这些死信消息, 让消费者重新消费；若您暂时无法处理这些死信消息, 为避免到期后死信消息被删除, 您也可以先将死信消息导出进行保存.

##### 死信消息具有以下特征

1. 不会再被消费者正常消费
2. 有效期和正常消息相同, 默认为3天, 3天后会被自动删除.

##### 死信队列具有以下特征

1. 一个死信队列对应一个Group ID, 而不是对应单个消费者实例
2. 如果一个Group ID未产生死信消息, 消息队列不会为其创建相应的死信队列
3. 一个死信队列包含了对应Group ID产生的所有死信消息, 不论该消息属于哪个Topic

#### 消息堆积

---

##### 消息堆积的场景

1. 消费者未注册成功
2. 消息生产者过快, 而消息消费过慢

##### 消息堆积解决方案

1. 提高消费并行度

   a. 同一个ConsumerGroup, 通过增加Consumer实例数量来提升并行度.

   b. 提高单个Consumer的消费线程, 通过修改参数`consumeThreadMin`、`consumeThreadMax`实现.

2. 批量消费方式

   a. 设置Consumer的consumeMessageBatchMaxSize参数.

3. 跳过非重要消息, 追赶上生产者进度

4. 优化消费代码逻辑













































