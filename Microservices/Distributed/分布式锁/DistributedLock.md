#### 分布式锁

##### 什么是分布式锁

分布式锁, 是控制分布式系统之间同步访问共享资源的一种方式. 在分布式系统中, 常常需要协调他们的动作. 如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源, 那么访问这些资源的时候, 往往需要互斥来阻止彼此干扰来保证一致性, 在这种情况下, 便需要使用到分布式锁.

#### 分布式锁实现方式

##### 基于Redis实现

**实现原理**: Redis的setNX(key, value);命令 - set value for key only if key does not exist. 

boolean isLock = redisClient.setNX(key, value);

try{

​	// 执行业务逻辑

}finally{

​	unlock();

}

---

**死锁问题**: 

boolean isLock = redisClient.setNX(key, value);

try{

​	// 执行业务逻辑

​	// 程序崩溃

}finally{

​	unlock();

}

当程序在执行业务代码时, 无法再执行到下面的解锁指令, 从而导致出现死锁问题.

**解决方案:** 引入过期时间的概念, 过期时间时给当前这个key设置一定的存活时间, 当存活时间到期后, Redis就会自动删除这个过期的key, 即使在执行业务逻辑程序崩溃也能到期自动释放锁.

boolean isLock = redisClient.setNX(key, value);

redisClient.expire(key, timeout);

try{

​	// 执行业务逻辑

​	// 程序崩溃

}finally{

​	unlock();

}

---

**解锁原理:** 删除key

---

**错误删除锁问题:** 

线程一获取锁成功, 但是执行业务时间过长导致锁过期.

线程二获取锁成功.

线程一执行业务完毕释放锁 - 线程二的锁.

线程三获取锁成功.

线程二和线程三存在并发问题.

**解决方案:** 加入锁标识

为了解决这种错误删除其他线程线程的锁这个问题, 需要在value字段里加入当前线程唯一标识, 线程在删除锁的时候需要和锁对应的value值进行比对, 只有是自己对应的标识时才可以进行锁删除.

String uuid = getUUId();

boolean isLock = redisClient.setNX(key, uuid, timeout);

try{

​	// 执行业务逻辑

}finally{

​	if(redisClient.getKey(key) == uuid){

​		unlock();

​	}

}

**异常场景:**

线程一获取锁，并执行业务逻辑

线程一执行完业务，比较锁对应的标识为自己加的锁, 进行删除时异常(线程挂起等异常)

线程一对应的锁自动过期

线程二获取到对应的锁

线程一继续执行, 释放了锁

线程三同时获取到了锁

线程二和线程三存在并发问题

**解决方案:** 比较和删除锁修改为原子操作 

String uuid = getUUId();

boolean isLock = redisClient.setNX(key, uuid, timeout);

try{

​	// 执行业务逻辑

}finally{

​	redisClient.eval(delLuaScript, key, value);

}

---

**引入Lua脚本实现原子操作:**

lua脚本是一个非常轻量级的脚本语言, Redis底层天生支持lua脚本执行, 一个lua脚本中可以包含多条Redis命令, Redis会将整个lua脚本当作原子操作来执行, 从而实现聚合多条Redis指令的原子操作.

---

**自动续租功能:**

**现象：**

在执行业务代码时, 由于执行业务时间过长导致锁自动失效, 然后锁自动释放, 在这种情况下其他线程会成功获取锁，导致产生并发问题.

**原因:**

设置的过期时间太短或者业务执行时间过长

**解决思路:**

开启一个定时任务, 自动刷新Redis加锁的超时时间

String uuid = getUUId();

boolean isLock = redisClient.setNX(key, uuid, timeout);

// 设置定时器

new Scheduler(key, time, uuid, scheduleTime);

try{

​	// 执行业务逻辑

}finally{

​	redisClient.eval(delLuaScript, key, value);

​	// 取消定时器

​	cancelScheduler(uuid);

}

定时器的逻辑:

1. 判断Reids的锁是否是自己的
2. 如果存在的话重新刷新过期时间

---

**可重入锁:**

**实现原理:**

使用Redis中的Map数据结构*Map(key, uuid, lockcount);

在加锁的时候增加锁次数, 在释放锁的时候减少锁次数

**获取锁逻辑:**

1. 判断锁是否不存在, 不存在则获取锁, 并记录加锁次数1
2. 如果锁存在, 则判断锁是否已获取, 如果没有获取到锁则等待, 如果获取到锁则增加锁次数

**释放锁逻辑:**

1. 判断锁是否是当前线程的, 是则加锁次数-1, 如果次数为0则释放锁



#### Redis和Redisson实现分布式锁的操作方法

---

#### 1. 基于setNX命令的分布式锁

##### 1.1 加锁

使用Redis实现分布式锁, 最直接的想法是利用`setNX`和`expire`命令实现加锁.

在Redis中, `setNX`是set if not exists 如果不存在则设置.

当一个线程执行`setnx`返回1, 说明key不存在设置成功, 该线程获得锁.

当一个线程执行`setnx`返回0, 说明key已经存在, 获取锁失败.

##### 1.2 释放锁

释放锁的话, 直接通过`DEL`命令删除对应的key即可.

为了防止误删到其它的锁, 我们建议在设置key的时候设置对应的value(可以是线程号)来判断.

释放锁的时候, 应先比较对应的锁的value是否相等, value值可以的在加锁的时候当前线程的线程ID, 在删除

之前验证key对应的value是不是自己的线程ID, 避免锁的误释放.

##### 1.3 setnx的缺点

使用`setNX`命令设置key必须设置一个超时时间, 以保证即使key没有被显式释放, 这把锁也要在一定时间后自动释放.

可以使用`expire`命令设置锁超时时间. 避免出现死锁现象.

##### 1.4 存在的问题

`setNX`和`expire`命令不是原子性操作的, 假设某个线程执行了`setNX`命令获取了锁, 但是还没来得及执行`expire`命令服务器挂掉了.

这样这把锁就没有设置过期时间, 变成了死锁.

#### 2. 基于set命令的分布式锁

##### 2.1 实现原理

redis的`set`命令支持在获取锁的同时设置key的过期时间

使用set命令加锁并设置锁过期时间：

```
set lockKey uniqueValue EX 3 NX
```

lockKey: 锁的名称

uniqueValue: 能够唯一标识锁的值

NX: 只有在lockKey不存在的时候才能set成功

EX: 过期时间设置(单位为秒). EX 3 表示这个lockKey有一个3秒自动过期的时间

##### 2.2 存在的问题

如果操作业务的时间大于过期时间, 就会出现锁提前过期的问题, 进而导致分布式锁失效, 如果这个锁的过期时间设置过长, 还会影响到性能问题.

##### 2.3 解决思路

我们可以让获得锁的线程开启一个守护线程, 用来给即将过期的锁进行自动续租.

在JAVA的Redisson中就有一个看门狗机制, 已经帮我们实现了这个功能.

#### 3. Redisson看门狗分布式锁

Redisson中的分布式锁自带自动续租机制, 使用起来非常简单, 其提供了一个专门用来监控和续租锁的Watch Dog(看门狗),

如果执行业务的线程还未执行结束的话, Watch Dog会不断延长锁的过期时间, 来保证锁不会因为超时而自动释放.

##### 3.1 加锁机制

线程去获取锁, 获取成功: 执行lua脚本, 保存数据到redis数据库.

此时另外一个线程去获取锁, 可以一直通过while循环尝试获取锁, 如果在获取锁的最大等待时间内加锁成功, 则执行lua脚本, 保存数据到redis数据库. 如果失败, 则返回加锁失败.

##### 3.2 watch dog自动延长机制

Redisson在获取锁之后, 会维护一个看门狗线程, 在每一个锁设置的过期时间的1/3处, 如果线程还未执行完业务, 则不断延长锁的有效期. 默认的锁过期时间是30秒, 可以通过lockWatchdoyTimeout参数来修改.

每没过10秒, 看门狗就会执行续租操作, 将锁的超时时间重置为30秒. 看门狗续租前也会先判断是否需要执行续租操作, 需要才会执行续租, 否则取消续租操作.

##### 3.3 redisson分布式锁的关键点

1. 如果对key不设置过期时间, 由Redisson在加锁成功后会维护一个watchdag看门狗, watchdog负责定时监听并处理, 在锁没有释放但快要过期的时候自动对锁进行续租, 保证解锁前不会自动失效.
2. 通过Lua脚本实现了加锁和解锁的原子操作, 底层使用setnx和lua脚本
3. 通过记录获取锁的客户端id, 每次加锁时判断是否当前客户端已经获得锁, 实现了可重入锁.

指定锁超时时间, 不会使用自动续租机制:

```
lock.trylock(10, 30, TimeUnit.SECONDS); // 设置锁释放时间, 不会使用自动续租操作
```

只有在未指定锁的超时时间, 才会用到Watch dog的自动续租机制:

```
lock.trylock(10, TimeUnit.SECONDS);
```







































