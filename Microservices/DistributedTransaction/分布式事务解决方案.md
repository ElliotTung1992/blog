#### 分布式事务解决方案

---

1. 二阶段提交(2PC)
2. 补偿事务(TCC)
3. 三阶段提交(3PC)
4. 本地消息表
5. 消息事务
6. Sagas事务模型



#### 二阶段提交

---

##### 基本算法:

1. 第一阶段 - 投票阶段

2. 第二阶段 - 提交执行

   a. 成功

   b. 失败

##### 实现方案:

1. Mysql基于XA协议实现分布式事务
1. Seata提供的AT模式

##### 实现一 - Seata的AT模式

AT模式基于支持本地ACID事务的关系型数据库:

1. 一阶段prepare行为: 在本地事务中，一并提交业务数据更新和相应回滚的日志记录
2. 二阶段commit行为: 马上成功结束，自动异步批量清理回滚日志
3. 二阶段rollback行为：通过回滚日志，自动生成补偿操作，完成数据回滚

缺点:

1. 缺乏隔离性的应对

##### 实现二 - Seata的XA模式

优点：

1. 业务无侵入
2. 数据库的支持广泛

缺点: 

1. XA prepare后，事务分支进入阻塞阶段，收到XA commit或XA rollback前必须阻塞等待。事务资源长时间得不到释放，锁定周期长，而且在应用层无法干预、性能差

使用场景: 适用于想要迁移到Seata平台基于XA协议的老应用，适用XA模式更加平滑，还有AT模式未适配的数据库应用

##### 实现三 - Mysql XA事务二阶段流程

1. 一阶段提交:
   1. 开始分布式事务: XA START xid
   2. 执行DML: 执行DML语句
   3. 将分布式事务xid置于IDLE状态: XA END xid
   4. 分布式事务本地提交: XA PREPARE xid
2. 二阶段提交:
   1. 事务最终提交: XA COMMIT xid
   2. 事务回滚: XA ROLLBACK xid

异常场景:

1. 查询处于prepare状态的XA事务: XA RECOVER

缺点:

1. 存在残留XA事务的场景
1. 存在事务阻塞场景



#### 补偿事务

---

##### 实现方案:

1. Seata TCC模式

##### Seata TCC模式

TCC模式，不依赖于底层数据库资源的事务支持

1. 一阶段prepare行为: 调用自定义的prepare逻辑
2. 二阶段commit行为: 调用自定义的commit逻辑
3. 二阶段rollback行为: 调用自定义的rollback逻辑

优点:

1. TCC完全不依赖底层数据库, 能够实现跨数据库、跨应用资源管理，可以提供给业务方更细粒度的控制

缺点:

1. TCC是一种侵入式的分布式事务解决方案，需要业务系统自行实现Try, confirm, cancel三个操作，对业务系统有非常大的入侵性，设计相对复杂

适用场景:

1. TCC模式是高性能分布式事务解决方案，适用于核心系统等对性能有很高要求的场景
2. 适用于需要强隔离性的分布式事务中
3. 适用于多数据库和多应用资源管理的业务中



#### 三阶段提交(Three-phase commit)

---

三阶段：

1. 决定阶段(CanCommit)
2. 准备提交段(PreCommit)
3. 执行阶段(DoCommit)

##### 三阶段提交与二阶段提交的区别

1. 同时在协调者和参与者中都引入超时机制
2. 3PC把2PC的准备准备阶段拆分成两个阶段
3. 在2PC中一个参与者的状态只有他自己和协调者知晓，假设协调者宕机等场景，参与者就会进入到既不能回滚，又不能强制commit的阻塞状态，知道协调者宕机恢复。

##### 三阶段提交协议

CanCommit阶段: 

> 尝试获得数据库锁，成功返回True, 失败返回False

PreCommit阶段: 

> 如果所有参与者在CanCommit阶段都返回Yes的话, 则进入PreCommit阶段进行事务预提交。
>
> 成功: 参与者收到PreCommit请求后，会执行事务操作，并将undo和redo的信息记录到事务日志中
>
> ​	  如果参与者成功执行了事务操作，则返回ACK响应，同时等待最终的指令 
>
> 异常: 如果任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者还没有到参与者的响应，则中断事务
>
> - 发送中断请求：协调者向所有参与者发送abort请求
> - 中断事务: 参与者收到协调者的abort请求或(超时之后，仍未收到协调者的请求)，执行事务中断

DoCommit阶段:

该阶段执行真正的事务提交，也可以分为以下两种:

> 执行提交：协调者接受到所有参与者的ack响应，发送执行提交，那么协调者将从预提交阶段进入到提交阶段，
>
> ​                    并向所有参与者发送doCommit请求。
>
> - 事务提交：参与者接收到doCommit请求之后，执行正式的事务提交。并在事务完成提交之后释放所有事务资源
> - 响应反馈：事务提交之后，向协调者发送ack响应
> - 完成事务：协调者接收到所有参与者的ack响应之后，完成全局事务
>
> 中断事务：协调者没有接受到参与者的ack响应(参与者发送的不是ack响应，也可能是响应超时)，则会执行事务中断
>
> - 发送中断请求：协调者向所有参与者发送abort请求
> - 事务回滚：参与者接收到abort请求之后，利用其在阶段二的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源
> - 反馈结果：参与者完成事务回滚之后，向协调者发送ack信息
> - 中断事务：协调者接收到参与者反馈的ack消息之后，执行全局事务中断

优点：

1. 能避免阻塞状态等

缺点:

1. 实现比较复杂

2. 存在数据不一致的问题，一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit，而不会一直持有事务资源并处于阻塞状态。

   

#### 本地消息表

---

eBay的本地消息表方案，一种通过本地数据库存储消息实现分布式事务的方式。

##### 核心思想：

将分布式事务拆分成本地事务进行处理，本地消息表是利用各系统本地事务来实现分布式事务。

业务系统的执行和消息均放入本地消息表中，确保本地业务执行和消息表的操作在一个事务中。

补偿机制是定时任务轮训读取本地消息表，调用远程应用程序。需要加入重试机制、最大执行次数、报警机制等；

本地消息表容忍数据暂时不一致，保证数据的最终一致性。

##### 优点：

1. 简单可靠：本地消息表是一种简单可靠的方案，通过将消息先存储到本地数据库中，再进行异步发送，可以保证

   消息的可靠性和一致性。

2. 高可用性：由于消息发送是异步的，即使目标服务不可用或出现故障，也不会影响当前事务的提交。

3. 高性能：使用发送消息的方式，将调用其它服务的过程异步化，减少了事务的等待时间，提升了系统的性能。

4. 无需提供回查方法，减少业务代码的侵入

5. 在某些场景下，还可以进一步利用注解等形式进行解耦合，有可能实现无业务代码入侵式的实现

##### 缺点：

1. 需要维护额外的数据库表和定时任务: 使用本地消息表需要额外维护一个存储消息的数据表，和进行消息重推的定时任务

   进行消息重推等逻辑，增加了系统的复杂性

2. 数据库依赖：本地消息依赖于数据库，如果数据库出现故障或者性能问题，会对整个系统的可用性和性能产生影响

3. 无法保证实时性：由于消息发送是异步的，无法保证数据的实时性，存在一定的延迟

4. 本地消息表和业务耦合在一起，难以通用伸缩性比较差

##### 注意点:

消息接口需要保证幂等性

需要额外增加一个定时任务进行消息补偿



#### 消息事务

---

##### 实现方案:

1. RocketMq



#### Saga事务模型

---

##### 使用场景:

1. 业务流程长、业务流程多
2. 参与者包含其它公司或遗留系统服务，无法提供TCC模式要求的三个接口

##### 优势：

1. 一阶段提交本地事务，无锁，高性能
2. 事件驱动架构，参与者可异步执行，高吞吐
3. 补偿服务易于实现

##### Saga服务设计的实践经验

允许空补偿:

- 空补偿: 原服务未执行，补偿服务执行了
- 出现原因:
  - 原服务超时(拥挤)
  - Saga事务触发回滚
  - 未收到原服务请求，先收到补偿请求

防悬挂控制:

- 悬挂: 补偿服务比原服务先执行
- 出现原因：
  - 原服务超时（拥堵）
  - Saga事务回滚，触发回滚
  - 拥堵的原服务达到

幂等控制:

- 原服务与补偿服务都需要保证幂等性，由于网络可能超时，可以设置重试策略，重试发生时要通过幂等控制避免业务数据重复更新



#### 设计规避

---

##### 大事务分解成小事务

场景: 积分商城下单发放奖品

整一个大事务:

1. 扣减库存/积分
2. 发放奖品

大事务分解成小事务:

1. 预生成订单: 扣减库存/积分
2. 发放奖品































