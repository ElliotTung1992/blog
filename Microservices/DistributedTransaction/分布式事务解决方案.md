#### 分布式事务解决方案

---

1. 二阶段提交(2PC)
2. 补偿事务(TCC)
3. 三阶段提交(3PC)
4. 本地消息表
5. 消息事务
6. Sagas事务模型



#### 二阶段提交

---

##### 基本算法:

1. 第一阶段 - 投票阶段

2. 第二阶段 - 提交执行

   a. 成功

   b. 失败

##### 实现方案:

1. Mysql基于XA协议实现分布式事务
1. Seata提供的AT模式

##### Seata的AT模式:

AT模式基于支持本地ACID事务的关系型数据库:

1. 一阶段prepare行为: 在本地事务中，一并提交业务数据更新和相应回滚的日志记录
2. 二阶段commit行为: 马上成功结束，自动异步批量清理回滚日志
3. 二阶段rollback行为：通过回滚日志，自动生成补偿操作，完成数据回滚

缺点:

1. 缺乏隔离性的应对

##### Mysql XA事务二阶段流程

1. 一阶段提交:
   1. 开始分布式事务: XA START xid
   2. 执行DML: 执行DML语句
   3. 将分布式事务xid置于IDLE状态: XA END xid
   4. 分布式事务本地提交: XA PREPARE xid
2. 二阶段提交:
   1. 事务最终提交: XA COMMIT xid
   2. 事务回滚: XA ROLLBACK xid

缺点:

1. 存在残留XA事务的场景



#### 补偿事务

---

##### 实现方案:

1. Seata TCC模式

##### Seata TCC模式

TCC模式，不依赖于底层数据库资源的事务支持

1. 一阶段prepare行为: 调用自定义的prepare逻辑
2. 二阶段commit行为: 调用自定义的commit逻辑
3. 二阶段rollback行为: 调用自定义的rollback逻辑

优点:

1. TCC完全不依赖底层数据库, 能够实现跨数据库、跨应用资源管理，可以提供给业务方更细粒度的控制

缺点:

1. TCC是一种侵入式的分布式事务解决方案，需要业务系统自行实现Try, confirm, cancel三个操作，对业务系统有非常大的入侵性，设计相对复杂

适用场景:

1. TCC模式是高性能分布式事务解决方案，适用于核心系统等对性能有很高要求的场景
2. 适用于需要强隔离性的分布式事务中
3. 适用于多数据库和多应用资源管理的业务中



#### 三阶段提交

---





#### 本地消息表

---





#### 消息事务

---

##### 实现方案:

1. RocketMq



#### Saga事务模型

---

##### 使用场景:

1. 业务流程长、业务流程多
2. 参与者包含其它公司或遗留系统服务，无法提供TCC模式要求的三个接口

##### 优势：

1. 一阶段提交本地事务，无锁，高性能
2. 事件驱动架构，参与者可异步执行，高吞吐
3. 补偿服务易于实现

##### Saga服务设计的实践经验

允许空补偿:

- 空补偿: 原服务未执行，补偿服务执行了
- 出现原因:
  - 原服务超时(拥挤)
  - Saga事务触发回滚
  - 未收到原服务请求，先收到补偿请求

防悬挂控制:

- 悬挂: 补偿服务比原服务先执行
- 出现原因：
  - 原服务超时（拥堵）
  - Saga事务回滚，触发回滚
  - 拥堵的原服务达到

幂等控制:

- 原服务与补偿服务都需要保证幂等性，由于网络可能超时，可以设置重试策略，重试发生时要通过幂等控制避免业务数据重复更新





































